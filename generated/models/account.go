// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Account account
//
// swagger:model Account
type Account struct {

	// attributes
	// Required: true
	Attributes *AccountAttributes `json:"attributes"`

	// Unique resource ID
	// Example: 7826c3cb-d6fd-41d0-b187-dc23ba928772
	// Required: true
	// Format: uuid
	ID *strfmt.UUID `json:"id"`

	// Unique ID of the organisation this resource is created by
	// Example: ee2fb143-6dfe-4787-b183-ca8ddd4164d2
	// Required: true
	// Format: uuid
	OrganisationID *strfmt.UUID `json:"organisation_id"`

	// relationships
	Relationships *AccountRelationships `json:"relationships,omitempty"`

	// Name of the resource type
	// Example: accounts
	// Pattern: ^[A-Za-z_]*$
	Type string `json:"type,omitempty"`

	// Version number
	// Example: 0
	// Minimum: 0
	Version *int64 `json:"version,omitempty"`
}

// Validate validates this account
func (m *Account) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrganisationID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRelationships(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Account) validateAttributes(formats strfmt.Registry) error {

	if err := validate.Required("attributes", "body", m.Attributes); err != nil {
		return err
	}

	if m.Attributes != nil {
		if err := m.Attributes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes")
			}
			return err
		}
	}

	return nil
}

func (m *Account) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateOrganisationID(formats strfmt.Registry) error {

	if err := validate.Required("organisation_id", "body", m.OrganisationID); err != nil {
		return err
	}

	if err := validate.FormatOf("organisation_id", "body", "uuid", m.OrganisationID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateRelationships(formats strfmt.Registry) error {
	if swag.IsZero(m.Relationships) { // not required
		return nil
	}

	if m.Relationships != nil {
		if err := m.Relationships.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("relationships")
			}
			return err
		}
	}

	return nil
}

func (m *Account) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	if err := validate.Pattern("type", "body", m.Type, `^[A-Za-z_]*$`); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if err := validate.MinimumInt("version", "body", *m.Version, 0, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this account based on the context it is used
func (m *Account) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRelationships(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Account) contextValidateAttributes(ctx context.Context, formats strfmt.Registry) error {

	if m.Attributes != nil {
		if err := m.Attributes.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes")
			}
			return err
		}
	}

	return nil
}

func (m *Account) contextValidateRelationships(ctx context.Context, formats strfmt.Registry) error {

	if m.Relationships != nil {
		if err := m.Relationships.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("relationships")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Account) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Account) UnmarshalBinary(b []byte) error {
	var res Account
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AccountAttributes account attributes
//
// swagger:model AccountAttributes
type AccountAttributes struct {

	// All accepted payments will receive the matching qualifier code
	// Enum: [some_other_time same_day next_calendar_day next_working_day after_next_working_day none]
	AcceptanceQualifier string `json:"acceptance_qualifier,omitempty"`

	// Is the account business or personal?
	// Enum: [Personal Business]
	AccountClassification *string `json:"account_classification,omitempty"`

	// Is the account opted out of account matching, e.g. CoP?
	AccountMatchingOptOut *bool `json:"account_matching_opt_out,omitempty"`

	// Account number of the account. A unique number will automatically be generated if not provided.
	// Example: 41426819
	// Pattern: ^[A-Z0-9]{0,64}$
	AccountNumber string `json:"account_number,omitempty"`

	// - deprecated - Alternative account names. Used for Confirmation of Payee matching.
	// Max Items: 3
	AlternativeBankAccountNames []string `json:"alternative_bank_account_names"`

	// Alternative names. Used for Confirmation of Payee matching.
	// Max Items: 3
	AlternativeNames []string `json:"alternative_names"`

	// - deprecated - Primary account name. Used for Confirmation of Payee matching. Required if confirmation_of_payee_enabled is true for the organisation.
	// Max Length: 140
	// Min Length: 1
	BankAccountName string `json:"bank_account_name,omitempty"`

	// Local country bank identifier. In the UK this is the sort code.
	// Example: 400300
	// Pattern: ^[A-Z0-9]{0,16}$
	BankID string `json:"bank_id,omitempty"`

	// ISO 20022 code used to identify the type of bank ID being used
	// Example: GBDSC
	// Pattern: ^[A-Z]{0,16}$
	BankIDCode string `json:"bank_id_code,omitempty"`

	// ISO 4217 code used to identify the base currency of the account
	// Example: GBP
	// Pattern: ^[A-Z]{3}$
	BaseCurrency string `json:"base_currency,omitempty"`

	// SWIFT BIC in either 8 or 11 character format
	// Example: NWBKGB22
	// Pattern: ^([A-Z]{6}[A-Z0-9]{2}|[A-Z]{6}[A-Z0-9]{5})$
	Bic string `json:"bic,omitempty"`

	// ISO 3166-1 code used to identify the domicile of the account
	// Example: GB
	// Required: true
	// Pattern: ^[A-Z]{2}$
	Country *string `json:"country"`

	// A free-format reference that can be used to link this account to an external system
	// Example: 12345
	// Pattern: ^[a-zA-Z0-9-$@., ]{0,256}$
	CustomerID string `json:"customer_id,omitempty"`

	// - deprecated - Customer first name.
	// Max Length: 40
	// Min Length: 1
	FirstName string `json:"first_name,omitempty"`

	// IBAN of the account. Will be calculated from other fields if not supplied.
	// Example: GB11NWBK40030041426819
	// Pattern: ^[A-Z]{2}[0-9]{2}[A-Z0-9]{0,64}$
	Iban string `json:"iban,omitempty"`

	// Is the account joint?
	JointAccount *bool `json:"joint_account,omitempty"`

	// Account holder names (for example title, first name, last name). Used for Confirmation of Payee matching.
	// Max Items: 4
	Name []string `json:"name"`

	// organisation identification
	OrganisationIdentification *AccountAttributesOrganisationIdentification `json:"organisation_identification,omitempty"`

	// private identification
	PrivateIdentification *AccountAttributesPrivateIdentification `json:"private_identification,omitempty"`

	// Accounting system or service. It will be added to each payment received to an account.
	// Max Length: 35
	ProcessingService string `json:"processing_service,omitempty"`

	// When set will apply a validation mask on the payment reference to each payment received to an account.
	// Example: 4929############
	// Max Length: 35
	ReferenceMask string `json:"reference_mask,omitempty"`

	// Secondary identification, e.g. building society roll number. Used for Confirmation of Payee.
	// Max Length: 140
	// Min Length: 1
	SecondaryIdentification string `json:"secondary_identification,omitempty"`

	// Current status of the account
	// Enum: [pending failed confirmed closed]
	Status string `json:"status,omitempty"`

	// Used to determine appropriate scheme or internal payment reject code. Account status field must be set to closed to use this functionality.
	// Example: transferred
	// Enum: [unspecified closed stopped currency transferred deceased business_reason none]
	StatusReason string `json:"status_reason,omitempty"`

	// Indicates whether the account has been switched using the Current Account Switch Service.
	Switched *bool `json:"switched,omitempty"`

	// - deprecated - Customer title.
	// Example: Ms
	// Max Length: 40
	// Min Length: 1
	Title string `json:"title,omitempty"`

	// All purpose field to store specific data for the associated account. It will be added to each payment received to an account.
	// Max Length: 35
	UserDefinedInformation string `json:"user_defined_information,omitempty"`

	// optional validation to apply to the account
	// Enum: [card none]
	ValidationType string `json:"validation_type,omitempty"`
}

// Validate validates this account attributes
func (m *AccountAttributes) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAcceptanceQualifier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountClassification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlternativeBankAccountNames(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlternativeNames(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankAccountName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankIDCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBaseCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIban(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrganisationIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivateIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessingService(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReferenceMask(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondaryIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatusReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserDefinedInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var accountAttributesTypeAcceptanceQualifierPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["some_other_time","same_day","next_calendar_day","next_working_day","after_next_working_day","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeAcceptanceQualifierPropEnum = append(accountAttributesTypeAcceptanceQualifierPropEnum, v)
	}
}

const (

	// AccountAttributesAcceptanceQualifierSomeOtherTime captures enum value "some_other_time"
	AccountAttributesAcceptanceQualifierSomeOtherTime string = "some_other_time"

	// AccountAttributesAcceptanceQualifierSameDay captures enum value "same_day"
	AccountAttributesAcceptanceQualifierSameDay string = "same_day"

	// AccountAttributesAcceptanceQualifierNextCalendarDay captures enum value "next_calendar_day"
	AccountAttributesAcceptanceQualifierNextCalendarDay string = "next_calendar_day"

	// AccountAttributesAcceptanceQualifierNextWorkingDay captures enum value "next_working_day"
	AccountAttributesAcceptanceQualifierNextWorkingDay string = "next_working_day"

	// AccountAttributesAcceptanceQualifierAfterNextWorkingDay captures enum value "after_next_working_day"
	AccountAttributesAcceptanceQualifierAfterNextWorkingDay string = "after_next_working_day"

	// AccountAttributesAcceptanceQualifierNone captures enum value "none"
	AccountAttributesAcceptanceQualifierNone string = "none"
)

// prop value enum
func (m *AccountAttributes) validateAcceptanceQualifierEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeAcceptanceQualifierPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateAcceptanceQualifier(formats strfmt.Registry) error {
	if swag.IsZero(m.AcceptanceQualifier) { // not required
		return nil
	}

	// value enum
	if err := m.validateAcceptanceQualifierEnum("attributes"+"."+"acceptance_qualifier", "body", m.AcceptanceQualifier); err != nil {
		return err
	}

	return nil
}

var accountAttributesTypeAccountClassificationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Personal","Business"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeAccountClassificationPropEnum = append(accountAttributesTypeAccountClassificationPropEnum, v)
	}
}

const (

	// AccountAttributesAccountClassificationPersonal captures enum value "Personal"
	AccountAttributesAccountClassificationPersonal string = "Personal"

	// AccountAttributesAccountClassificationBusiness captures enum value "Business"
	AccountAttributesAccountClassificationBusiness string = "Business"
)

// prop value enum
func (m *AccountAttributes) validateAccountClassificationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeAccountClassificationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateAccountClassification(formats strfmt.Registry) error {
	if swag.IsZero(m.AccountClassification) { // not required
		return nil
	}

	// value enum
	if err := m.validateAccountClassificationEnum("attributes"+"."+"account_classification", "body", *m.AccountClassification); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateAccountNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.AccountNumber) { // not required
		return nil
	}

	if err := validate.Pattern("attributes"+"."+"account_number", "body", m.AccountNumber, `^[A-Z0-9]{0,64}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateAlternativeBankAccountNames(formats strfmt.Registry) error {
	if swag.IsZero(m.AlternativeBankAccountNames) { // not required
		return nil
	}

	iAlternativeBankAccountNamesSize := int64(len(m.AlternativeBankAccountNames))

	if err := validate.MaxItems("attributes"+"."+"alternative_bank_account_names", "body", iAlternativeBankAccountNamesSize, 3); err != nil {
		return err
	}

	for i := 0; i < len(m.AlternativeBankAccountNames); i++ {

		if err := validate.MinLength("attributes"+"."+"alternative_bank_account_names"+"."+strconv.Itoa(i), "body", m.AlternativeBankAccountNames[i], 1); err != nil {
			return err
		}

		if err := validate.MaxLength("attributes"+"."+"alternative_bank_account_names"+"."+strconv.Itoa(i), "body", m.AlternativeBankAccountNames[i], 140); err != nil {
			return err
		}

	}

	return nil
}

func (m *AccountAttributes) validateAlternativeNames(formats strfmt.Registry) error {
	if swag.IsZero(m.AlternativeNames) { // not required
		return nil
	}

	iAlternativeNamesSize := int64(len(m.AlternativeNames))

	if err := validate.MaxItems("attributes"+"."+"alternative_names", "body", iAlternativeNamesSize, 3); err != nil {
		return err
	}

	for i := 0; i < len(m.AlternativeNames); i++ {

		if err := validate.MinLength("attributes"+"."+"alternative_names"+"."+strconv.Itoa(i), "body", m.AlternativeNames[i], 1); err != nil {
			return err
		}

		if err := validate.MaxLength("attributes"+"."+"alternative_names"+"."+strconv.Itoa(i), "body", m.AlternativeNames[i], 140); err != nil {
			return err
		}

	}

	return nil
}

func (m *AccountAttributes) validateBankAccountName(formats strfmt.Registry) error {
	if swag.IsZero(m.BankAccountName) { // not required
		return nil
	}

	if err := validate.MinLength("attributes"+"."+"bank_account_name", "body", m.BankAccountName, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("attributes"+"."+"bank_account_name", "body", m.BankAccountName, 140); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateBankID(formats strfmt.Registry) error {
	if swag.IsZero(m.BankID) { // not required
		return nil
	}

	if err := validate.Pattern("attributes"+"."+"bank_id", "body", m.BankID, `^[A-Z0-9]{0,16}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateBankIDCode(formats strfmt.Registry) error {
	if swag.IsZero(m.BankIDCode) { // not required
		return nil
	}

	if err := validate.Pattern("attributes"+"."+"bank_id_code", "body", m.BankIDCode, `^[A-Z]{0,16}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateBaseCurrency(formats strfmt.Registry) error {
	if swag.IsZero(m.BaseCurrency) { // not required
		return nil
	}

	if err := validate.Pattern("attributes"+"."+"base_currency", "body", m.BaseCurrency, `^[A-Z]{3}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateBic(formats strfmt.Registry) error {
	if swag.IsZero(m.Bic) { // not required
		return nil
	}

	if err := validate.Pattern("attributes"+"."+"bic", "body", m.Bic, `^([A-Z]{6}[A-Z0-9]{2}|[A-Z]{6}[A-Z0-9]{5})$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateCountry(formats strfmt.Registry) error {

	if err := validate.Required("attributes"+"."+"country", "body", m.Country); err != nil {
		return err
	}

	if err := validate.Pattern("attributes"+"."+"country", "body", *m.Country, `^[A-Z]{2}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateCustomerID(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomerID) { // not required
		return nil
	}

	if err := validate.Pattern("attributes"+"."+"customer_id", "body", m.CustomerID, `^[a-zA-Z0-9-$@., ]{0,256}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(m.FirstName) { // not required
		return nil
	}

	if err := validate.MinLength("attributes"+"."+"first_name", "body", m.FirstName, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("attributes"+"."+"first_name", "body", m.FirstName, 40); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateIban(formats strfmt.Registry) error {
	if swag.IsZero(m.Iban) { // not required
		return nil
	}

	if err := validate.Pattern("attributes"+"."+"iban", "body", m.Iban, `^[A-Z]{2}[0-9]{2}[A-Z0-9]{0,64}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	iNameSize := int64(len(m.Name))

	if err := validate.MaxItems("attributes"+"."+"name", "body", iNameSize, 4); err != nil {
		return err
	}

	for i := 0; i < len(m.Name); i++ {

		if err := validate.MinLength("attributes"+"."+"name"+"."+strconv.Itoa(i), "body", m.Name[i], 1); err != nil {
			return err
		}

		if err := validate.MaxLength("attributes"+"."+"name"+"."+strconv.Itoa(i), "body", m.Name[i], 140); err != nil {
			return err
		}

	}

	return nil
}

func (m *AccountAttributes) validateOrganisationIdentification(formats strfmt.Registry) error {
	if swag.IsZero(m.OrganisationIdentification) { // not required
		return nil
	}

	if m.OrganisationIdentification != nil {
		if err := m.OrganisationIdentification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "organisation_identification")
			}
			return err
		}
	}

	return nil
}

func (m *AccountAttributes) validatePrivateIdentification(formats strfmt.Registry) error {
	if swag.IsZero(m.PrivateIdentification) { // not required
		return nil
	}

	if m.PrivateIdentification != nil {
		if err := m.PrivateIdentification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "private_identification")
			}
			return err
		}
	}

	return nil
}

func (m *AccountAttributes) validateProcessingService(formats strfmt.Registry) error {
	if swag.IsZero(m.ProcessingService) { // not required
		return nil
	}

	if err := validate.MaxLength("attributes"+"."+"processing_service", "body", m.ProcessingService, 35); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateReferenceMask(formats strfmt.Registry) error {
	if swag.IsZero(m.ReferenceMask) { // not required
		return nil
	}

	if err := validate.MaxLength("attributes"+"."+"reference_mask", "body", m.ReferenceMask, 35); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateSecondaryIdentification(formats strfmt.Registry) error {
	if swag.IsZero(m.SecondaryIdentification) { // not required
		return nil
	}

	if err := validate.MinLength("attributes"+"."+"secondary_identification", "body", m.SecondaryIdentification, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("attributes"+"."+"secondary_identification", "body", m.SecondaryIdentification, 140); err != nil {
		return err
	}

	return nil
}

var accountAttributesTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["pending","failed","confirmed","closed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeStatusPropEnum = append(accountAttributesTypeStatusPropEnum, v)
	}
}

const (

	// AccountAttributesStatusPending captures enum value "pending"
	AccountAttributesStatusPending string = "pending"

	// AccountAttributesStatusFailed captures enum value "failed"
	AccountAttributesStatusFailed string = "failed"

	// AccountAttributesStatusConfirmed captures enum value "confirmed"
	AccountAttributesStatusConfirmed string = "confirmed"

	// AccountAttributesStatusClosed captures enum value "closed"
	AccountAttributesStatusClosed string = "closed"
)

// prop value enum
func (m *AccountAttributes) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("attributes"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

var accountAttributesTypeStatusReasonPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unspecified","closed","stopped","currency","transferred","deceased","business_reason","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeStatusReasonPropEnum = append(accountAttributesTypeStatusReasonPropEnum, v)
	}
}

const (

	// AccountAttributesStatusReasonUnspecified captures enum value "unspecified"
	AccountAttributesStatusReasonUnspecified string = "unspecified"

	// AccountAttributesStatusReasonClosed captures enum value "closed"
	AccountAttributesStatusReasonClosed string = "closed"

	// AccountAttributesStatusReasonStopped captures enum value "stopped"
	AccountAttributesStatusReasonStopped string = "stopped"

	// AccountAttributesStatusReasonCurrency captures enum value "currency"
	AccountAttributesStatusReasonCurrency string = "currency"

	// AccountAttributesStatusReasonTransferred captures enum value "transferred"
	AccountAttributesStatusReasonTransferred string = "transferred"

	// AccountAttributesStatusReasonDeceased captures enum value "deceased"
	AccountAttributesStatusReasonDeceased string = "deceased"

	// AccountAttributesStatusReasonBusinessReason captures enum value "business_reason"
	AccountAttributesStatusReasonBusinessReason string = "business_reason"

	// AccountAttributesStatusReasonNone captures enum value "none"
	AccountAttributesStatusReasonNone string = "none"
)

// prop value enum
func (m *AccountAttributes) validateStatusReasonEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeStatusReasonPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateStatusReason(formats strfmt.Registry) error {
	if swag.IsZero(m.StatusReason) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusReasonEnum("attributes"+"."+"status_reason", "body", m.StatusReason); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateTitle(formats strfmt.Registry) error {
	if swag.IsZero(m.Title) { // not required
		return nil
	}

	if err := validate.MinLength("attributes"+"."+"title", "body", m.Title, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("attributes"+"."+"title", "body", m.Title, 40); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributes) validateUserDefinedInformation(formats strfmt.Registry) error {
	if swag.IsZero(m.UserDefinedInformation) { // not required
		return nil
	}

	if err := validate.MaxLength("attributes"+"."+"user_defined_information", "body", m.UserDefinedInformation, 35); err != nil {
		return err
	}

	return nil
}

var accountAttributesTypeValidationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["card","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountAttributesTypeValidationTypePropEnum = append(accountAttributesTypeValidationTypePropEnum, v)
	}
}

const (

	// AccountAttributesValidationTypeCard captures enum value "card"
	AccountAttributesValidationTypeCard string = "card"

	// AccountAttributesValidationTypeNone captures enum value "none"
	AccountAttributesValidationTypeNone string = "none"
)

// prop value enum
func (m *AccountAttributes) validateValidationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountAttributesTypeValidationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AccountAttributes) validateValidationType(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateValidationTypeEnum("attributes"+"."+"validation_type", "body", m.ValidationType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this account attributes based on the context it is used
func (m *AccountAttributes) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateOrganisationIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrivateIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountAttributes) contextValidateOrganisationIdentification(ctx context.Context, formats strfmt.Registry) error {

	if m.OrganisationIdentification != nil {
		if err := m.OrganisationIdentification.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "organisation_identification")
			}
			return err
		}
	}

	return nil
}

func (m *AccountAttributes) contextValidatePrivateIdentification(ctx context.Context, formats strfmt.Registry) error {

	if m.PrivateIdentification != nil {
		if err := m.PrivateIdentification.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "private_identification")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AccountAttributes) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountAttributes) UnmarshalBinary(b []byte) error {
	var res AccountAttributes
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AccountAttributesOrganisationIdentification account attributes organisation identification
//
// swagger:model AccountAttributesOrganisationIdentification
type AccountAttributesOrganisationIdentification struct {

	// actors
	Actors []*AccountAttributesOrganisationIdentificationActorsItems0 `json:"actors"`

	// address
	Address []string `json:"address"`

	// city
	// Max Length: 35
	// Min Length: 1
	City string `json:"city,omitempty"`

	// country
	// Example: GB
	// Pattern: ^[A-Z]{2}$
	Country string `json:"country,omitempty"`

	// identification
	// Max Length: 140
	// Min Length: 1
	Identification string `json:"identification,omitempty"`

	// identification issuer
	IdentificationIssuer string `json:"identification_issuer,omitempty"`

	// identification scheme
	// Max Length: 35
	// Min Length: 1
	IdentificationScheme string `json:"identification_scheme,omitempty"`

	// identification scheme code
	// Max Length: 35
	// Min Length: 1
	IdentificationSchemeCode string `json:"identification_scheme_code,omitempty"`

	// registration number
	RegistrationNumber string `json:"registration_number,omitempty"`

	// ISO 3166-1 code used to identify the domicile of the account
	// Example: GB
	// Pattern: ^[A-Z]{2}$
	TaxResidency string `json:"tax_residency,omitempty"`
}

// Validate validates this account attributes organisation identification
func (m *AccountAttributesOrganisationIdentification) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdentificationScheme(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdentificationSchemeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaxResidency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountAttributesOrganisationIdentification) validateActors(formats strfmt.Registry) error {
	if swag.IsZero(m.Actors) { // not required
		return nil
	}

	for i := 0; i < len(m.Actors); i++ {
		if swag.IsZero(m.Actors[i]) { // not required
			continue
		}

		if m.Actors[i] != nil {
			if err := m.Actors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributes" + "." + "organisation_identification" + "." + "actors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AccountAttributesOrganisationIdentification) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	for i := 0; i < len(m.Address); i++ {

		if err := validate.MinLength("attributes"+"."+"organisation_identification"+"."+"address"+"."+strconv.Itoa(i), "body", m.Address[i], 1); err != nil {
			return err
		}

		if err := validate.MaxLength("attributes"+"."+"organisation_identification"+"."+"address"+"."+strconv.Itoa(i), "body", m.Address[i], 140); err != nil {
			return err
		}

	}

	return nil
}

func (m *AccountAttributesOrganisationIdentification) validateCity(formats strfmt.Registry) error {
	if swag.IsZero(m.City) { // not required
		return nil
	}

	if err := validate.MinLength("attributes"+"."+"organisation_identification"+"."+"city", "body", m.City, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("attributes"+"."+"organisation_identification"+"."+"city", "body", m.City, 35); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributesOrganisationIdentification) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(m.Country) { // not required
		return nil
	}

	if err := validate.Pattern("attributes"+"."+"organisation_identification"+"."+"country", "body", m.Country, `^[A-Z]{2}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributesOrganisationIdentification) validateIdentification(formats strfmt.Registry) error {
	if swag.IsZero(m.Identification) { // not required
		return nil
	}

	if err := validate.MinLength("attributes"+"."+"organisation_identification"+"."+"identification", "body", m.Identification, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("attributes"+"."+"organisation_identification"+"."+"identification", "body", m.Identification, 140); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributesOrganisationIdentification) validateIdentificationScheme(formats strfmt.Registry) error {
	if swag.IsZero(m.IdentificationScheme) { // not required
		return nil
	}

	if err := validate.MinLength("attributes"+"."+"organisation_identification"+"."+"identification_scheme", "body", m.IdentificationScheme, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("attributes"+"."+"organisation_identification"+"."+"identification_scheme", "body", m.IdentificationScheme, 35); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributesOrganisationIdentification) validateIdentificationSchemeCode(formats strfmt.Registry) error {
	if swag.IsZero(m.IdentificationSchemeCode) { // not required
		return nil
	}

	if err := validate.MinLength("attributes"+"."+"organisation_identification"+"."+"identification_scheme_code", "body", m.IdentificationSchemeCode, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("attributes"+"."+"organisation_identification"+"."+"identification_scheme_code", "body", m.IdentificationSchemeCode, 35); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributesOrganisationIdentification) validateTaxResidency(formats strfmt.Registry) error {
	if swag.IsZero(m.TaxResidency) { // not required
		return nil
	}

	if err := validate.Pattern("attributes"+"."+"organisation_identification"+"."+"tax_residency", "body", m.TaxResidency, `^[A-Z]{2}$`); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this account attributes organisation identification based on the context it is used
func (m *AccountAttributesOrganisationIdentification) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateActors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountAttributesOrganisationIdentification) contextValidateActors(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Actors); i++ {

		if m.Actors[i] != nil {
			if err := m.Actors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributes" + "." + "organisation_identification" + "." + "actors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AccountAttributesOrganisationIdentification) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountAttributesOrganisationIdentification) UnmarshalBinary(b []byte) error {
	var res AccountAttributesOrganisationIdentification
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AccountAttributesOrganisationIdentificationActorsItems0 account attributes organisation identification actors items0
//
// swagger:model AccountAttributesOrganisationIdentificationActorsItems0
type AccountAttributesOrganisationIdentificationActorsItems0 struct {

	// birth date
	// Example: 2017-07-23
	// Format: date
	BirthDate *strfmt.Date `json:"birth_date,omitempty"`

	// Actor names (for example title, first name, last name). Used for Confirmation of Payee matching.
	// Max Items: 4
	Name []string `json:"name"`

	// ISO 3166-1 code used to identify the domicile of the actor
	// Example: GB
	// Pattern: ^[A-Z]{2}$
	Residency string `json:"residency,omitempty"`

	// role
	Role string `json:"role,omitempty"`
}

// Validate validates this account attributes organisation identification actors items0
func (m *AccountAttributesOrganisationIdentificationActorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBirthDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResidency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountAttributesOrganisationIdentificationActorsItems0) validateBirthDate(formats strfmt.Registry) error {
	if swag.IsZero(m.BirthDate) { // not required
		return nil
	}

	if err := validate.FormatOf("birth_date", "body", "date", m.BirthDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributesOrganisationIdentificationActorsItems0) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	iNameSize := int64(len(m.Name))

	if err := validate.MaxItems("name", "body", iNameSize, 4); err != nil {
		return err
	}

	for i := 0; i < len(m.Name); i++ {

		if err := validate.MinLength("name"+"."+strconv.Itoa(i), "body", m.Name[i], 1); err != nil {
			return err
		}

		if err := validate.MaxLength("name"+"."+strconv.Itoa(i), "body", m.Name[i], 255); err != nil {
			return err
		}

	}

	return nil
}

func (m *AccountAttributesOrganisationIdentificationActorsItems0) validateResidency(formats strfmt.Registry) error {
	if swag.IsZero(m.Residency) { // not required
		return nil
	}

	if err := validate.Pattern("residency", "body", m.Residency, `^[A-Z]{2}$`); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this account attributes organisation identification actors items0 based on context it is used
func (m *AccountAttributesOrganisationIdentificationActorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AccountAttributesOrganisationIdentificationActorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountAttributesOrganisationIdentificationActorsItems0) UnmarshalBinary(b []byte) error {
	var res AccountAttributesOrganisationIdentificationActorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AccountAttributesPrivateIdentification account attributes private identification
//
// swagger:model AccountAttributesPrivateIdentification
type AccountAttributesPrivateIdentification struct {

	// address
	Address []string `json:"address"`

	// birth country
	// Example: GB
	// Pattern: ^[A-Z]{2}$
	BirthCountry string `json:"birth_country,omitempty"`

	// Customer birth date
	// Example: 2017-07-23
	// Format: date
	BirthDate *strfmt.Date `json:"birth_date,omitempty"`

	// city
	// Max Length: 35
	// Min Length: 1
	City string `json:"city,omitempty"`

	// country
	// Example: GB
	// Pattern: ^[A-Z]{2}$
	Country string `json:"country,omitempty"`

	// identification
	// Example: L-123456789
	// Max Length: 140
	// Min Length: 1
	Identification string `json:"identification,omitempty"`

	// identification issuer
	// Min Length: 1
	IdentificationIssuer string `json:"identification_issuer,omitempty"`

	// identification scheme
	// Max Length: 35
	// Min Length: 1
	IdentificationScheme string `json:"identification_scheme,omitempty"`

	// identification scheme code
	// Max Length: 35
	// Min Length: 1
	IdentificationSchemeCode string `json:"identification_scheme_code,omitempty"`
}

// Validate validates this account attributes private identification
func (m *AccountAttributesPrivateIdentification) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBirthCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBirthDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdentificationIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdentificationScheme(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdentificationSchemeCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountAttributesPrivateIdentification) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.Address) { // not required
		return nil
	}

	for i := 0; i < len(m.Address); i++ {

		if err := validate.MinLength("attributes"+"."+"private_identification"+"."+"address"+"."+strconv.Itoa(i), "body", m.Address[i], 1); err != nil {
			return err
		}

		if err := validate.MaxLength("attributes"+"."+"private_identification"+"."+"address"+"."+strconv.Itoa(i), "body", m.Address[i], 140); err != nil {
			return err
		}

	}

	return nil
}

func (m *AccountAttributesPrivateIdentification) validateBirthCountry(formats strfmt.Registry) error {
	if swag.IsZero(m.BirthCountry) { // not required
		return nil
	}

	if err := validate.Pattern("attributes"+"."+"private_identification"+"."+"birth_country", "body", m.BirthCountry, `^[A-Z]{2}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributesPrivateIdentification) validateBirthDate(formats strfmt.Registry) error {
	if swag.IsZero(m.BirthDate) { // not required
		return nil
	}

	if err := validate.FormatOf("attributes"+"."+"private_identification"+"."+"birth_date", "body", "date", m.BirthDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributesPrivateIdentification) validateCity(formats strfmt.Registry) error {
	if swag.IsZero(m.City) { // not required
		return nil
	}

	if err := validate.MinLength("attributes"+"."+"private_identification"+"."+"city", "body", m.City, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("attributes"+"."+"private_identification"+"."+"city", "body", m.City, 35); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributesPrivateIdentification) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(m.Country) { // not required
		return nil
	}

	if err := validate.Pattern("attributes"+"."+"private_identification"+"."+"country", "body", m.Country, `^[A-Z]{2}$`); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributesPrivateIdentification) validateIdentification(formats strfmt.Registry) error {
	if swag.IsZero(m.Identification) { // not required
		return nil
	}

	if err := validate.MinLength("attributes"+"."+"private_identification"+"."+"identification", "body", m.Identification, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("attributes"+"."+"private_identification"+"."+"identification", "body", m.Identification, 140); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributesPrivateIdentification) validateIdentificationIssuer(formats strfmt.Registry) error {
	if swag.IsZero(m.IdentificationIssuer) { // not required
		return nil
	}

	if err := validate.MinLength("attributes"+"."+"private_identification"+"."+"identification_issuer", "body", m.IdentificationIssuer, 1); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributesPrivateIdentification) validateIdentificationScheme(formats strfmt.Registry) error {
	if swag.IsZero(m.IdentificationScheme) { // not required
		return nil
	}

	if err := validate.MinLength("attributes"+"."+"private_identification"+"."+"identification_scheme", "body", m.IdentificationScheme, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("attributes"+"."+"private_identification"+"."+"identification_scheme", "body", m.IdentificationScheme, 35); err != nil {
		return err
	}

	return nil
}

func (m *AccountAttributesPrivateIdentification) validateIdentificationSchemeCode(formats strfmt.Registry) error {
	if swag.IsZero(m.IdentificationSchemeCode) { // not required
		return nil
	}

	if err := validate.MinLength("attributes"+"."+"private_identification"+"."+"identification_scheme_code", "body", m.IdentificationSchemeCode, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("attributes"+"."+"private_identification"+"."+"identification_scheme_code", "body", m.IdentificationSchemeCode, 35); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this account attributes private identification based on context it is used
func (m *AccountAttributesPrivateIdentification) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AccountAttributesPrivateIdentification) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountAttributesPrivateIdentification) UnmarshalBinary(b []byte) error {
	var res AccountAttributesPrivateIdentification
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AccountRelationships account relationships
//
// swagger:model AccountRelationships
type AccountRelationships struct {

	// account events
	AccountEvents *AccountRelationshipsAccountEvents `json:"account_events,omitempty"`

	// master account
	MasterAccount *AccountRelationshipsMasterAccount `json:"master_account,omitempty"`
}

// Validate validates this account relationships
func (m *AccountRelationships) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountEvents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMasterAccount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountRelationships) validateAccountEvents(formats strfmt.Registry) error {
	if swag.IsZero(m.AccountEvents) { // not required
		return nil
	}

	if m.AccountEvents != nil {
		if err := m.AccountEvents.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("relationships" + "." + "account_events")
			}
			return err
		}
	}

	return nil
}

func (m *AccountRelationships) validateMasterAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.MasterAccount) { // not required
		return nil
	}

	if m.MasterAccount != nil {
		if err := m.MasterAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("relationships" + "." + "master_account")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this account relationships based on the context it is used
func (m *AccountRelationships) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccountEvents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMasterAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountRelationships) contextValidateAccountEvents(ctx context.Context, formats strfmt.Registry) error {

	if m.AccountEvents != nil {
		if err := m.AccountEvents.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("relationships" + "." + "account_events")
			}
			return err
		}
	}

	return nil
}

func (m *AccountRelationships) contextValidateMasterAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.MasterAccount != nil {
		if err := m.MasterAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("relationships" + "." + "master_account")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AccountRelationships) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountRelationships) UnmarshalBinary(b []byte) error {
	var res AccountRelationships
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AccountRelationshipsAccountEvents account relationships account events
//
// swagger:model AccountRelationshipsAccountEvents
type AccountRelationshipsAccountEvents struct {

	// data
	Data []*AccountRelationshipsAccountEventsDataItems0 `json:"data"`
}

// Validate validates this account relationships account events
func (m *AccountRelationshipsAccountEvents) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountRelationshipsAccountEvents) validateData(formats strfmt.Registry) error {
	if swag.IsZero(m.Data) { // not required
		return nil
	}

	for i := 0; i < len(m.Data); i++ {
		if swag.IsZero(m.Data[i]) { // not required
			continue
		}

		if m.Data[i] != nil {
			if err := m.Data[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("relationships" + "." + "account_events" + "." + "data" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this account relationships account events based on the context it is used
func (m *AccountRelationshipsAccountEvents) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountRelationshipsAccountEvents) contextValidateData(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Data); i++ {

		if m.Data[i] != nil {
			if err := m.Data[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("relationships" + "." + "account_events" + "." + "data" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AccountRelationshipsAccountEvents) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountRelationshipsAccountEvents) UnmarshalBinary(b []byte) error {
	var res AccountRelationshipsAccountEvents
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AccountRelationshipsAccountEventsDataItems0 account relationships account events data items0
//
// swagger:model AccountRelationshipsAccountEventsDataItems0
type AccountRelationshipsAccountEventsDataItems0 struct {

	// ID of the referenced resource
	// Format: uuid
	ID strfmt.UUID `json:"id,omitempty"`

	// Name of the referenced resource type
	Type string `json:"type,omitempty"`
}

// Validate validates this account relationships account events data items0
func (m *AccountRelationshipsAccountEventsDataItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountRelationshipsAccountEventsDataItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this account relationships account events data items0 based on context it is used
func (m *AccountRelationshipsAccountEventsDataItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AccountRelationshipsAccountEventsDataItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountRelationshipsAccountEventsDataItems0) UnmarshalBinary(b []byte) error {
	var res AccountRelationshipsAccountEventsDataItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AccountRelationshipsMasterAccount account relationships master account
//
// swagger:model AccountRelationshipsMasterAccount
type AccountRelationshipsMasterAccount struct {

	// data
	Data []*AccountRelationshipsMasterAccountDataItems0 `json:"data"`
}

// Validate validates this account relationships master account
func (m *AccountRelationshipsMasterAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountRelationshipsMasterAccount) validateData(formats strfmt.Registry) error {
	if swag.IsZero(m.Data) { // not required
		return nil
	}

	for i := 0; i < len(m.Data); i++ {
		if swag.IsZero(m.Data[i]) { // not required
			continue
		}

		if m.Data[i] != nil {
			if err := m.Data[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("relationships" + "." + "master_account" + "." + "data" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this account relationships master account based on the context it is used
func (m *AccountRelationshipsMasterAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountRelationshipsMasterAccount) contextValidateData(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Data); i++ {

		if m.Data[i] != nil {
			if err := m.Data[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("relationships" + "." + "master_account" + "." + "data" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AccountRelationshipsMasterAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountRelationshipsMasterAccount) UnmarshalBinary(b []byte) error {
	var res AccountRelationshipsMasterAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AccountRelationshipsMasterAccountDataItems0 account relationships master account data items0
//
// swagger:model AccountRelationshipsMasterAccountDataItems0
type AccountRelationshipsMasterAccountDataItems0 struct {

	// ID of the referenced resource
	// Format: uuid
	ID strfmt.UUID `json:"id,omitempty"`

	// Name of the referenced resource type
	Type string `json:"type,omitempty"`
}

// Validate validates this account relationships master account data items0
func (m *AccountRelationshipsMasterAccountDataItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AccountRelationshipsMasterAccountDataItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this account relationships master account data items0 based on context it is used
func (m *AccountRelationshipsMasterAccountDataItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AccountRelationshipsMasterAccountDataItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AccountRelationshipsMasterAccountDataItems0) UnmarshalBinary(b []byte) error {
	var res AccountRelationshipsMasterAccountDataItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
